/* Electron Interference's hardware map for ftc 2019-2020 */

package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.hardware.bosch.BNO055IMU;
import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.HardwareMap;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.hardware.bosch.BNO055IMU;


    /* 
    * Robot Functions
    ****************************************** Complete ***********************************************
    *
    * moveInches(float distance [inches]) - Moves a specified number of inches - void
    *
    ***************************************** Incomplete **********************************************
    *
    * 
    *
    ****************************************** Planned ************************************************
    *
    * turnDegrees(int degrees [degrees clockwise]) - Turns a specified number of degrees - void
    * moveToPosition(int x [inches from left side], int y [inches from audience side] ) - moves to 
    * a specific location on the field - void
    * detectSkystoneLocation() - looks for a skystone using vuforia - returns distance to the right
    * Strafe(int distance [inches], direction [degrees]) - strafes in any direction
    * 
    */

public class HardwareBot {
    
    
    //Drive Motors
    public DcMotor  flDrive   = null;
    public DcMotor  frDrive   = null;
    public DcMotor  blDrive      = null;
    public DcMotor  brDrive      = null;
    public BNO055IMU imu;
    public DcMotor  lift         = null;
    public DcMotor  arm          = null;
    public DcMotor lintake       = null;
    public DcMotor rintake       = null;
    
    public Servo lClaw           = null; 
    public Servo rClaw           = null; 
    public CRServo lCenterIntake =null;
    public CRServo rCenterIntake =null;

    // Drive variables
    public int wheel_diameter = 4;
    public float gear_ratio = 1; // PLACEHOLDER VALUE
    public float strafing_efficiency = 0; // PLACEHOLDER VALUE
    public double distance_per_rotation = wheel_diameter*3.14159625357989*gear_ratio;

    
    HardwareMap hwMap           =  null;
    
    // Constructor
    public HardwareBot() {
        

        
    }
    
    
    public void init(HardwareMap ahwMap) {
        hwMap = ahwMap;

        // Define motors
        flDrive  = hwMap.get(DcMotor.class, "flDrive");
        frDrive  = hwMap.get(DcMotor.class, "frDrive");
        blDrive  = hwMap.get(DcMotor.class, "blDrive");
        brDrive  = hwMap.get(DcMotor.class, "brDrive");
        
        lift  = hwMap.get(DcMotor.class, "lift");
        arm  = hwMap.get(DcMotor.class, "arm");
        
        lClaw = hwMap.get(Servo.class, "lClaw");
        rClaw = hwMap.get(Servo.class, "rClaw");
        
        lCenterIntake = hwMap.get(CRServo.class, "lCenterIntake");
        rCenterIntake = hwMap.get(CRServo.class, "rCenterIntake");
        
        //set all motors to use encoders
        flDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        frDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        blDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        brDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        
        // Set the direction of the motors
        flDrive.setDirection(DcMotor.Direction.FORWARD);
        frDrive.setDirection(DcMotor.Direction.FORWARD);
        blDrive.setDirection(DcMotor.Direction.FORWARD);
        brDrive.setDirection(DcMotor.Direction.FORWARD);
    }
    
    //moves a specified number of inches
    public void moveInches(float distance) {
        
        // reset the encoders
        flDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        flDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        flDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        flDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        
        // set the motors to run to a specified position
        flDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        frDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        blDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        brDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        
        // set the motors to run to the set number of inches, accounting for ratios
        flDrive.setTargetPosition((int)(distance*distance_per_rotation));
        frDrive.setTargetPosition((int)(distance*distance_per_rotation));
        blDrive.setTargetPosition((int)(distance*distance_per_rotation));
        brDrive.setTargetPosition((int)(distance*distance_per_rotation)); 
        
        // start the motors
        flDrive.setPower(1);
        frDrive.setPower(1);
        blDrive.setPower(1);
        brDrive.setPower(1);
        
    }
    //Turn a desired number of degrees
    public void turnDegrees(int target) {
        //try to turn four times. This improves precision
        for(int i = 0; i < 4; i ++) {
            
            //Run the motors without encoders
            blDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            brDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            frDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            flDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            brDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODERS);
            blDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODERS);
            frDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODERS);
            flDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODERS);
            
            //find our current heading
            float currentAngle = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES).firstAngle;
            //if we need to turn left...
            if(currentAngle > target) {
                //turn left
                blDrive.setPower(-0.3);
                flDrive.setPower(-0.3);
                brDrive.setPower(0.3);
                frDrive.setPower(0.3);
                
          
            }
        }
    }
}
